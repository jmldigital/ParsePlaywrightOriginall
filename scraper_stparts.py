# scraper_stparts_async.py
"""
–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä stparts.ru —á–µ—Ä–µ–∑ Playwright
–° –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∫–∞–ø—á–∏, fallback-–ø–æ–∏—Å–∫–∞ –∏ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ "–≤ –Ω–∞–ª–∏—á–∏–∏"
"""
import datetime
import re
import base64
from playwright.async_api import Page, TimeoutError as PlaywrightTimeout
from twocaptcha import TwoCaptcha
from config import SELECTORS, API_KEY_2CAPTCHA
from utils import logger, parse_price, brand_matches
import asyncio
import logging
from utils import get_site_logger
logger = get_site_logger("stparts")


BASE_URL = "https://stparts.ru"
WAIT_TIMEOUT = 8000  # –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥ (8 —Å–µ–∫—É–Ω–¥)


async def solve_image_captcha_async(page: Page) -> bool:
    """–†–µ—à–µ–Ω–∏–µ –∫–∞–ø—á–∏ —á–µ—Ä–µ–∑ 2Captcha"""
    try:
        solver = TwoCaptcha(API_KEY_2CAPTCHA)
        captcha_img = page.locator(SELECTORS["stparts"]["captcha_img"])
        if not await captcha_img.is_visible():
            return False

        # –ü–æ–ª—É—á–∞–µ–º base64 –∏–∑ Playwright
        captcha_bytes = await captcha_img.screenshot()
        captcha_base64 = base64.b64encode(captcha_bytes).decode("utf-8")

        logger.info("–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–∞–ø—á—É –Ω–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ –≤ 2Captcha")
        result = await asyncio.to_thread(solver.normal, captcha_base64)
        captcha_text = result["code"]
        logger.info(f"–ö–∞–ø—á–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞: {captcha_text}")

        input_el = page.locator(SELECTORS["stparts"]["captcha_input"])
        await input_el.fill(captcha_text)
        await page.locator(f"#{SELECTORS['stparts']['captcha_submit']}").click()

        await page.wait_for_timeout(5000)
        return True
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ä–µ—à–µ–Ω–∏—è –∫–∞–ø—á–∏: {e}")
        return False


async def wait_for_results_or_no_results_async(page: Page) -> str:
    """–û–∂–∏–¥–∞–µ—Ç –ø–æ—è–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–ª–∏ –±–ª–æ–∫–∞ '–Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤'"""
    try:
        await page.wait_for_function(
            """
            (selector) => document.querySelector(selector) ||
                  document.querySelector('div.fr-alert.fr-alert-warning.alert-noResults')
            """,
            arg=SELECTORS["stparts"]["results_table"],
            timeout=WAIT_TIMEOUT,
        )

        if await page.locator("div.fr-alert.fr-alert-warning.alert-noResults").is_visible():
            logger.info("üö´ –ù–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —É–∫–∞–∑–∞–Ω –±–ª–æ–∫ '–Ω–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤'")
            return "no_results"

        return "has_results"
    except PlaywrightTimeout:
        logger.warning("‚ö†Ô∏è –ò—Å—Ç—ë–∫ —Ç–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –ø–æ—è–≤–ª–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")
        return "timeout"




async def scrape_stparts_async(page: Page, brand: str, part: str, logger: logging.Logger) -> tuple:
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –ø–∞—Ä—Å–µ—Ä stparts.ru —Å –ø–µ—Ä–µ–¥–∞—á–µ–π –ª–æ–≥–≥–µ—Ä–∞."""
    try:
        url = f"{BASE_URL}/search/{brand}/{part}"
        await page.goto(url)
        logger.info(f"–ó–∞–≥—Ä—É–∂–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞: {url}")

        if await page.locator(SELECTORS["stparts"]["captcha_img"]).is_visible():
            logger.warning("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∫–∞–ø—á–∞ –Ω–∞ stparts.ru")
            if not await solve_image_captcha_async(page):
                logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–µ—à–∏—Ç—å –∫–∞–ø—á—É")
                return None, None

        status = await wait_for_results_or_no_results_async(page)
        if status != "has_results":
            return None, None

        table = page.locator(SELECTORS["stparts"]["results_table"])
        await table.wait_for(state="visible", timeout=WAIT_TIMEOUT)
        rows = table.locator(SELECTORS["stparts"]["result_row"])
        row_count = await rows.count()

        if row_count == 0:
            logger.info(f"–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è {brand} / {part}")
            return None, None

        logger.info(f"–ù–∞–π–¥–µ–Ω–æ {row_count} —Å—Ç—Ä–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")

        async def find_best_result(priority_search: bool):
            for i in range(row_count):
                row = rows.nth(i)
                try:
                    brand_in_row = (await row.locator(SELECTORS["stparts"]["brand"]).text_content() or "").strip()
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è brand_in_row –¥–ª—è —Å—Ç—Ä–æ–∫–∏ {i}: {e}")
                    continue

                if not brand_matches(brand, brand_in_row):
                    continue
                try:
                    delivery_min = (await row.locator(SELECTORS["stparts"]["delivery"]).text_content() or "").strip()
                    price_text = (await row.locator(SELECTORS["stparts"]["price"]).text_content() or "").strip()
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç—Ä–æ–∫–∏ {i}: {e}")
                    continue
                try:
                    if priority_search and not re.match(r"^1(\D|$)", delivery_min):
                        continue
                    price = parse_price(price_text)
                    if price is not None:
                        logger.info(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ (–±—Ä–µ–Ω–¥: {brand_in_row}, —Å—Ä–æ–∫ {delivery_min}): {price} ‚ÇΩ")
                        return price, delivery_min
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Ç—Ä–æ–∫–∏ {i}: {e}")
            return None, None

        result = await find_best_result(priority_search=True)
        if not result[0]:
            result = await find_best_result(priority_search=False)

        if result[0]:
            return result

        logger.info(f"‚ùå –ü–æ–¥—Ö–æ–¥—è—â–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è {brand} / {part}")
        return None, None

    except PlaywrightTimeout:
        logger.warning(f"‚è∞ –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è {brand} / {part}")
        return await fallback_search_async(page, brand, part)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å—Ç–∞—Ä—Ç–æ–≤ –¥–ª—è {brand} / {part}: {e}")
        # –ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        await page.screenshot(path=f"screenshots/error_{brand}_{part}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png")
        return None, None


async def fallback_search_async(page: Page, brand: str, part: str) -> tuple:
    """Fallback-–ø–æ–∏—Å–∫ —Ç–æ–ª—å–∫–æ –ø–æ –Ω–æ–º–µ—Ä—É –¥–µ—Ç–∞–ª–∏"""
    try:
        fallback_url = f"{BASE_URL}/search?pcode={part}"
        await page.goto(fallback_url)
        logger.info(f"Fallback: –∑–∞–≥—Ä—É–∂–µ–Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –±–µ–∑ –±—Ä–µ–Ω–¥–∞: {fallback_url}")

        if await page.locator(SELECTORS["stparts"]["captcha_img"]).is_visible():
            logger.warning("–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –∫–∞–ø—á–∞ –Ω–∞ stparts.ru (fallback)")
            if not await solve_image_captcha_async(page):
                logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–µ—à–∏—Ç—å –∫–∞–ø—á—É (fallback)")
                return None, None

        status = await wait_for_results_or_no_results_async(page)
        if status != "has_results":
            return None, None

        table = page.locator(SELECTORS["stparts"]["results_table"])
        await table.wait_for(state="visible", timeout=WAIT_TIMEOUT)
        rows = table.locator(SELECTORS["stparts"]["result_row"])
        row_count = await rows.count()

        if row_count == 0:
            logger.info(f"Fallback: —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è {part}")
            return None, None

        logger.info(f"Fallback: –Ω–∞–π–¥–µ–Ω–æ {row_count} —Å—Ç—Ä–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")

        async def find_best_result(priority_search: bool):
            for i in range(row_count):
                row = rows.nth(i)
                brand_in_row = (await row.locator(SELECTORS["stparts"]["brand"]).text_content() or "").strip()

                if not brand_matches(brand, brand_in_row):
                    continue

                delivery_min = (await row.locator(SELECTORS["stparts"]["delivery"]).text_content() or "").strip()
                if priority_search and not re.match(r"^1(\D|$)", delivery_min):
                    continue

                price_text = (await row.locator(SELECTORS["stparts"]["price"]).text_content() or "").strip()
                price = parse_price(price_text)
                if price is not None:
                    logger.info(f"Fallback: –Ω–∞–π–¥–µ–Ω–æ (–±—Ä–µ–Ω–¥: {brand_in_row}, —Å—Ä–æ–∫ {delivery_min}): {price} ‚ÇΩ")
                    return price, delivery_min
            return None, None

        result = await find_best_result(priority_search=True)
        if not result[0]:
            result = await find_best_result(priority_search=False)

        if result[0]:
            return result
        logger.info(f"Fallback: –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è {part}")
        return None, None

    except PlaywrightTimeout:
        logger.error(f"Fallback Timeout –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è {part}")
        return None, None
    except Exception as e:
        logger.error(f"Fallback –æ—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ stparts –¥–ª—è {part}: {e}")
        return None, None
